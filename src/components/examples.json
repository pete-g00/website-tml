{
  "aNbMcNM": "# accept strings containing a's, b's and c's,\n# with a's before b's before c's, and the number of c's \n# equal to the number of a's and b's\nalphabet = [a, b, c]\nmodule aNbMcNM():\n    # base case => blank\n    if blank:\n        accept\n    # base case => cannot start with a c\n    if c:\n        reject\n    # a => remove it, go to the end and remove c\n    if a:\n        move end\n        # c => remove it and restart from the beginning\n        if c:\n            changeto blank\n            move start\n            goto aNbMcNM()\n        else:\n            reject\n    # b => go to bMcM (but don't move)\n    if b:\n        move left\n        move right\n        goto bMcM()\n# accept strings starting with b's followed by the same number of c's\n# no a's accepted\nmodule bMcM():\n    # base case => blank\n    if blank:\n        accept\n    # base case => cannot start with a or c\n    if a, c:\n        reject\n    # b => remove it, go to the end and remove c\n    if b:\n        move end\n        # c => remove it and restart from the beginning\n        if c:\n            changeto blank\n            move start\n            goto bMcM()\n        else:\n            reject\n",
  "aNbN": "# accepts strings of the form a^nb^n for some n >= 0\n# e.g. blank, ab, aabb, aaabbb, etc.\nalphabet = [a, b]\nmodule aNbN():\n    # empty string => base case, accept\n    if blank:\n        accept\n    # cannot start with b\n    if b:\n        reject\n    # starts with a => remove the last b\n    if a:\n        changeto blank\n        move end\n        # ends with b => move to the start and restart\n        if b:\n            changeto blank\n            move start\n            goto aNbN()\n        else:\n            reject\n",
  "aNbNcN": "# accepts strings of the form a^nb^nc^n for some n >= 0\n# e.g. blank, abc, aabbcc, aaabbbccc, etc.\n# aim: at each iteration, remove a, b and c, so:\n# - if there's only one a at the start, check we have \"abc\"\n# - otherwise, remove the first two a's, the first b becomes an a, and remove the last c\nalphabet = [a, b, c]\nmodule aNbNcN():\n    # base case => accept blank\n    if blank:\n        accept\n    if a:\n        changeto blank\n        move right\n        # aa => find the first b and replace it with a\n        if a:\n            move right\n            while a:\n                move right\n            if b:\n                changeto a\n                move end\n                # remove the last character (which must be a c) and restart\n                if c:\n                    changeto blank\n                    move start\n                    goto aNbNcN()\n                else:\n                    reject\n            else:\n                reject\n        # b => check we have abc\n        if b:\n            changeto blank\n            move right\n            if c:\n                changeto blank\n                accept\n            else:\n                reject\n        # otherwise => we don't have a followed by b\n        else:\n            reject\n    # otherwise => b or c at the start\n    else:\n        reject\n",
  "equalAB": "# checks whether a string has an equal number of a's and b's\n# The module is recursive, and in one iteration should remove one a and one b.\n# Base it on the first value (if a at the start, remove the last b; and vice versa). \nalphabet = [a, b]\nmodule equalAB():\n    # base case => accept blank\n    if blank:\n        accept\n    # a: remove it, go to the end and remove the last b\n    if a:\n        changeto blank\n        move end\n        goto removeLast(b, a)\n    # b: remove it, go to the end and remove the last a\n    if b:\n        changeto blank\n        move end\n        goto removeLast(a, b)\n# given that the tape is positioned at the end,\n# removes the last x from the tape\nmodule removeLast(x, y):\n    # last character x => remove it and restart\n    if x:\n        changeto blank\n        move start\n        goto equalAB()\n    # last character y => remove it, \n    # and replace the last x with an y\n    if y:\n        changeto blank\n        move left\n        while x:\n            move left\n        if y:\n            changeto x\n            move start\n            goto equalAB()\n        # no a's => more b's than a's\n        else:\n            reject\n    # otherwise => last character blank => more y's than x's\n    else:\n        reject\n",
  "isDiv2": "# checks whether a binary number is divisible by 2\n# i.e. accept only if the last letter is 0\nalphabet = [0, 1]\nmodule isDiv2():\n    move end\n    if 0:\n        accept\n    else:\n        reject\n",
  "isDiv4": "# checks whether a binary number is divisible by 4\n# i.e. accept only if the last letter is 0 and the second last is 0 or blank\nalphabet = [0, 1]\nmodule isDiv4():\n    move end\n    if 0:\n        move left\n        if 0, blank:\n            accept\n        else:\n            reject\n    else:\n        reject\n"
}